# Huffman Algorithm – Сжатие и восстановление файлов

## Цель работы

Реализовать алгоритм Хаффмана для сжатия и последующего восстановления текстовых файлов. Освоить префиксное кодирование с переменной длиной кода и работу с динамическими структурами данных (связанный список, бинарное дерево) для построения эффективного алгоритма сжатия без потерь. [attached_file:1]

## Постановка задачи

Программа работает в двух режимах: `encode` и `decode`. [attached_file:1]

### Режим `encode`

В режиме кодирования программа: [attached_file:1]

1. Анализирует входной файл и определяет частоты появления каждого символа.
2. По таблице частот строит дерево Хаффмана и таблицу двоичных кодов символов.
3. Кодирует исходный файл, заменяя каждый символ его кодом Хаффмана.
4. Записывает в выходной бинарный файл:
   - таблицу частот (256 байт);
   - длину исходного файла (количество символов);
   - последовательность закодированных бит, упакованных в байты. [attached_file:1]

### Режим `decode`

В режиме декодирования программа: [attached_file:1]

1. Считывает из сжатого файла таблицу частот и длину исходного файла.
2. Восстанавливает по ним дерево Хаффмана.
3. Читает байты закодированных данных, разбирает каждый байт по битам и спускается по дереву (0 – влево, 1 – вправо).
4. При достижении листа записывает соответствующий символ в выходной файл.
5. Останавливается, когда количество декодированных символов достигает сохранённой длины исходного файла, что позволяет игнорировать добитые нули в конце. [attached_file:1]

Гарантируется возможность повторного декодирования без потерь и совпадение исходного и восстановленного файлов (проверяется отдельно). [attached_file:1]

## Структуры данных

Основная структура узла дерева и списка:

struct node_t {
unsigned char symbol; // символ (только в листьях)
unsigned long long frequency; // частота символа или суммарная частота поддерева
struct node_t *next; // следующий элемент в отсортированном списке
struct node_t *left; // левый потомок в дереве (бит 0)
struct node_t *right; // правый потомок в дереве (бит 1)
};


Используется: [attached_file:1]

- отсортированный по возрастанию частоты связанный список для построения дерева;
- бинарное дерево Хаффмана;
- таблица кодов `code_table_t`, где для каждого символа хранится массив битов и длина кода. [attached_file:1]

## Ключевые функции

### Построение дерева и таблицы кодов

- `list_from_freq_array` – создаёт отсортированный список всех символов с ненулевой частотой. [attached_file:1]
- `insert_node` – вставляет узел в список с сохранением порядка по частоте.
- `make_new_node` – объединяет два минимальных узла в новый внутренний узел.
- `make_tree` – последовательно объединяет минимальные узлы, пока не останется один корень дерева. [attached_file:1]
- `make_code_table` – рекурсивно обходит дерево: при переходе влево добавляет к коду бит 0, при переходе вправо – бит 1; для листьев сохраняет полученный код в таблицу. [attached_file:1]

### Кодирование

`int encode_file(const char *input_filename,
                 const char *output_filename,
                 code_table_t *table,
                 unsigned char *frequencies,
                 long input_len);`

Функция: [attached_file:1]

1. Записывает в сжатый файл:
   - 256 байт таблицы частот;
   - длину исходного файла (`input_len`).
2. Повторно читает исходный файл и для каждого символа берёт его двоичный код из `table`.
3. По одному добавляет биты к времённому байту `buffer`. Каждый раз, когда накапливается 8 бит, записывает байт в файл.
4. Если в конце остаётся неполный байт, дополняет его нулями и также записывает.

### Декодирование

`int decode_file(const char *input_filename,
                 const char *output_filename);`

Функция: [attached_file:1]

1. Считывает 256 байт частот и длину исходного файла.
2. Строит дерево Хаффмана по таблице частот.
3. Читает каждый байт сжатых данных, последовательно извлекает из него биты (старший → младший), и по этим битам двигается по дереву:
   - 0 – к левому сыну,
   - 1 – к правому сыну.
4. При достижении листа выводит один символ в выходной файл и возвращается к корню.
5. Декодирует, пока количество выданных символов не достигнет сохранённой длины исходного файла.

## Интерфейс программы

Главная функция `main(int argc, char *argv[])` использует аргументы командной строки: [attached_file:1]

Режим кодирования
./hahman encode input.txt compressed.bin decoded.txt

Режим декодирования
./hahman decode compressed.bin output.txt


- В режиме `encode` дополнительно выполняется автоматическое декодирование в `decoded.txt` и проверка совпадения с исходным файлом.
- При отсутствии или неверном наборе аргументов программа выводит подсказку по использованию.

## Статистика и проверка корректности

Реализованы вспомогательные функции:

- `long get_file_size(const char *filename)` – возвращает размер файла в байтах.
- `int files_equal(const char *f1, const char *f2)` – побайтово сравнивает два файла и возвращает 1, если они совпадают.

В режиме `encode` программа: [attached_file:1]

- сравнивает исходный и декодированный файлы и выводит результат проверки;
- выводит размеры:
  - исходного файла;
  - сжатого файла;
  - декодированного файла;
- рассчитывает коэффициент сжатия как `size_in / size_compressed`. [attached_file:1]

Дополнительно (опционально) можно: [attached_file:1]

- сохранять таблицу кодов символов в текстовый файл;
- сохранять текстовое представление дерева Хаффмана.

## Результаты

Реализованная программа: [attached_file:1]

- работает в режимах `encode` и `decode`;
- сохраняет в сжатом файле всю необходимую информацию для восстановления (частоты и длину исходного файла);
- обеспечивает корректное восстановление исходного текста (проверено сравнением файлов);
- выводит основную статистику, включая коэффициент сжатия.

Это соответствует требованиям варианта 2 лабораторной работы по алгоритму Хаффмана.
